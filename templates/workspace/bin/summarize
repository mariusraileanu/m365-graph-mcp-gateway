#!/usr/bin/env bash
set -euo pipefail

BIN="/home/node/.openclaw/tools/npm-global/bin/summarize"
CACHE_DIR="/home/node/.openclaw/cache/summarize"
MEMORY_DIR="/home/node/.openclaw/workspace/memory"
mkdir -p "$CACHE_DIR"

write_memory_breadcrumb() {
  local key="$1"
  local cache_file="$2"
  local input="$3"
  shift 3
  local args=("$@")

  [[ "$input" =~ ^https?:// ]] || return 0

  mkdir -p "$MEMORY_DIR"
  local mem_file="${MEMORY_DIR}/$(date +%F).md"
  if grep -Fq "summary-cache-key: \`$key\`" "$mem_file" 2>/dev/null; then
    return 0
  fi

  local now_utc preview
  now_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  preview="$(
    head -c 320 "$cache_file" \
      | tr '\n' ' ' \
      | sed 's/[[:space:]]\+/ /g'
  )"
  {
    echo ""
    echo "### Summary Cache"
    echo "- summary-cache-key: \`$key\`"
    echo "- source: $input"
    echo "- cached-at: $now_utc"
    echo "- command: \`summarize ${args[*]}\`"
    echo "- preview: $preview"
  } >> "$mem_file"
}

# Build a stable cache key from the full request args. This makes repeated
# summarize requests with the same input + options return instantly.
KEY="$(
  python3 - "$@" <<'PY'
import hashlib
import json
import sys

payload = {"v": 1, "args": sys.argv[1:]}
raw = json.dumps(payload, separators=(",", ":"), ensure_ascii=True).encode("utf-8")
print(hashlib.sha256(raw).hexdigest())
PY
)"

CACHE_FILE="${CACHE_DIR}/${KEY}.txt"
META_FILE="${CACHE_DIR}/${KEY}.json"

if [[ -f "$CACHE_FILE" ]]; then
  write_memory_breadcrumb "$KEY" "$CACHE_FILE" "${1:-}" "$@"
  cat "$CACHE_FILE"
  exit 0
fi

TMP_FILE="$(mktemp)"
set +e
"$BIN" "$@" >"$TMP_FILE" 2>&1
STATUS=$?
set -e

if [[ $STATUS -eq 0 ]]; then
  cat "$TMP_FILE" | tee "$CACHE_FILE" >/dev/null
  python3 - "$META_FILE" "$CACHE_FILE" "$@" <<'PY'
import json
import os
import sys
from datetime import datetime, timezone

meta_file = sys.argv[1]
cache_file = sys.argv[2]
args = sys.argv[3:]
meta = {
    "cachedAt": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    "args": args,
    "cacheFile": cache_file,
    "bytes": os.path.getsize(cache_file),
}
with open(meta_file, "w", encoding="utf-8") as f:
    json.dump(meta, f, ensure_ascii=True, separators=(",", ":"))
PY

  # Also persist a compact memory breadcrumb for cross-session retrieval.
  # This complements deterministic cache with semantic memory_search visibility.
  write_memory_breadcrumb "$KEY" "$CACHE_FILE" "${1:-}" "$@"

  rm -f "$TMP_FILE"
  exit 0
fi

cat "$TMP_FILE"
rm -f "$TMP_FILE"
exit $STATUS
