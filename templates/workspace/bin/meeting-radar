#!/usr/bin/env python3
import json
import re
import subprocess
import sys
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

TZ = ZoneInfo("Asia/Dubai")
UTC = timezone.utc
USER_EMAIL = "mlucian@doh.gov.ae"
FALLBACK_CONTEXT = [
    "â€¢ No related context found in mailbox for this meeting.",
    "â€¢ No immediate blocker identified from recent correspondence.",
    "â€¢ No unresolved prior action found in matched context.",
]
STOPWORDS = {
    "the", "and", "for", "with", "from", "that", "this", "into", "your", "you",
    "meeting", "sync", "call", "session", "review", "update", "intro", "introducing",
    "new", "process", "digital", "health",
}


def clean(text: str) -> str:
    text = re.sub(r"\s+", " ", (text or "").strip())
    text = "".join(ch for ch in text if ch.isprintable())
    return text


def run_json(cmd):
    out = subprocess.check_output(cmd, text=True)
    payload = json.loads(out)
    if isinstance(payload, dict) and "result" in payload:
        return payload["result"]
    return payload


def parse_event_dt(item, key):
    value = (item.get(key) or {}).get("dateTime")
    if not value:
        return None
    value = value.replace("Z", "+00:00")
    dt = datetime.fromisoformat(value)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=UTC)
    return dt.astimezone(TZ)


def strategic_value(subject: str) -> str:
    s = subject.lower()
    if any(k in s for k in ["steerco", "approve", "approval", "decision", "cab", "review", "clarification"]):
        return "Decision Required: Alignment or decision points are likely in this meeting."
    if any(k in s for k in ["sync", "alignment", "catch-up", "update", "ways of work"]):
        return "Alignment: Cross-team coordination and shared understanding are the primary focus."
    return "FYI: Informational session; monitor outcomes and dependencies."


def presence(item) -> str:
    attendees = item.get("attendees") or []
    required_emails = {
        ((a.get("emailAddress") or {}).get("address") or "").lower()
        for a in attendees
        if (a.get("type") or "").lower() == "required"
    }
    optional_emails = {
        ((a.get("emailAddress") or {}).get("address") or "").lower()
        for a in attendees
        if (a.get("type") or "").lower() == "optional"
    }
    if USER_EMAIL in required_emails:
        return "Critical"
    if USER_EMAIL in optional_emails:
        return "Recommended"
    return "Nice-to-have"


def recommendation(subject: str, value: str, pres: str) -> str:
    if pres == "Critical":
        return "Join on time and drive clear decisions, owners, and next steps before closing."
    if value.startswith("Decision Required"):
        return "Attend and capture decisions, risks, and ownership to prevent execution delays."
    if value.startswith("Alignment"):
        return "Attend if possible to align scope and dependencies with stakeholders."
    return "Review outcomes afterward and engage only if decisions affect your priorities."


def participants(item):
    org = clean((((item.get("organizer") or {}).get("emailAddress") or {}).get("name")) or "Unknown organizer")
    req = []
    opt = []
    for a in item.get("attendees") or []:
        name = clean(((a.get("emailAddress") or {}).get("name")) or ((a.get("emailAddress") or {}).get("address")) or "")
        if not name:
            continue
        if (a.get("type") or "").lower() == "optional":
            opt.append(name)
        else:
            req.append(name)
    if not req:
        req = ["Not specified"]
    if not opt:
        opt = ["None"]
    return org, req, opt


def short_list(items, limit=6):
    if len(items) <= limit:
        return ", ".join(items)
    return ", ".join(items[:limit]) + f", +{len(items) - limit} more"


def subject_keywords(subject: str):
    tokens = re.findall(r"[A-Za-z0-9][A-Za-z0-9&-]{1,}", subject or "")
    keys = []
    for t in tokens:
        k = t.lower()
        if k in STOPWORDS or len(k) < 3:
            continue
        keys.append(t)
        if len(keys) >= 5:
            break
    return keys


def context_bullets(item):
    org_email = clean((((item.get("organizer") or {}).get("emailAddress") or {}).get("address")) or "")
    subject = clean(item.get("subject") or "")
    keys = subject_keywords(subject)
    q = " ".join(([org_email] if org_email else []) + keys).strip()
    if not q:
        return FALLBACK_CONTEXT
    try:
        matches = run_json(["/home/node/workspace/bin/mail-search", "8", q])
    except Exception:
        return FALLBACK_CONTEXT
    if not isinstance(matches, list):
        return FALLBACK_CONTEXT
    for m in matches:
        msub = clean(m.get("subject") or "")
        sender = clean((((m.get("from") or {}).get("emailAddress") or {}).get("name")) or "")
        rcv = clean(m.get("receivedDateTime") or "")
        if not msub:
            continue
        if re.search(r"[^A-Za-z0-9 .,:;()&'\"/+_-]", msub):
            continue
        date_txt = ""
        try:
            d = datetime.fromisoformat(rcv.replace("Z", "+00:00")).astimezone(TZ)
            date_txt = d.strftime("%Y-%m-%d")
        except Exception:
            pass
        line = f"â€¢ Related thread: {msub}"
        if sender:
            line += f" ({sender}"
            if date_txt:
                line += f", {date_txt}"
            line += ")"
        return [line, FALLBACK_CONTEXT[1], FALLBACK_CONTEXT[2]]
    return FALLBACK_CONTEXT


def label_for_window(mode, value):
    now = datetime.now(TZ)
    if mode == "today":
        return f"Today, {now.strftime('%Y-%m-%d')}, GMT+4"
    if mode == "tomorrow":
        return f"Tomorrow, {(now + timedelta(days=1)).strftime('%Y-%m-%d')}, GMT+4"
    if mode == "week":
        return f"This Week, {now.strftime('%Y-%m-%d')}, GMT+4"
    return f"Next {value} Minutes"


def usage():
    print("Usage: meeting-radar <today|tomorrow|week|next> [minutes]", file=sys.stderr)
    sys.exit(1)


def main():
    if len(sys.argv) < 2:
        usage()
    mode = sys.argv[1].lower()
    minutes = "60"
    if mode == "next":
        if len(sys.argv) >= 3:
            minutes = sys.argv[2]
            if not re.fullmatch(r"\d+", minutes):
                usage()
        events = run_json(["/home/node/workspace/bin/calendar-next", minutes])
    elif mode == "today":
        events = run_json(["/home/node/workspace/bin/calendar-today"])
    elif mode == "tomorrow":
        events = run_json(["/home/node/workspace/bin/calendar-tomorrow"])
    elif mode == "week":
        events = run_json(["/home/node/workspace/bin/calendar-week"])
    else:
        usage()
    if not isinstance(events, list):
        events = []
    events = sorted(events, key=lambda e: ((e.get("start") or {}).get("dateTime") or ""))

    lines = [
        f"ğŸ“… Executive Meeting Radar ({label_for_window(mode, minutes)})",
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "",
    ]
    if not events:
        lines.append("No meetings found for this window.")
        print("\n".join(lines))
        return

    for idx, item in enumerate(events):
        start = parse_event_dt(item, "start")
        end = parse_event_dt(item, "end")
        time_line = "Unknown time"
        if start and end:
            time_line = f"{start.strftime('%H:%M')} - {end.strftime('%H:%M')} (GMT+4)"
        subject = clean(item.get("subject") or "Untitled meeting")
        location = clean(((item.get("location") or {}).get("displayName")) or "Virtual")
        if not location:
            location = "Virtual"
        org, req, opt = participants(item)
        value = strategic_value(subject)
        pres = presence(item)
        rec = recommendation(subject, value, pres)
        ctx = context_bullets(item)

        lines.extend([
            f"ğŸ•’ {time_line}",
            subject,
            f"ğŸŒ Location: {location}",
            "",
            "ğŸ‘¥ Participants:",
            "",
            f"â€¢ Organizer: {org}",
            f"â€¢ Required: {short_list(req)}",
            f"â€¢ Optional: {short_list(opt)}",
            "ğŸ¯ Strategic Value:",
            value,
            "",
            "ğŸ™‹ Your Presence:",
            pres,
            "",
            "âœ… Recommendation:",
            rec,
            "",
            "ğŸ§  Strategic Context:",
            ctx[0],
            ctx[1],
            ctx[2],
        ])
        if idx != len(events) - 1:
            lines.extend(["", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", ""])

    print("\n".join(lines))


if __name__ == "__main__":
    main()
